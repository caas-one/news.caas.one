# Litmus:存储e2e之旅和Kubernetes的混沌架构（94）

本文是关于Litmus的#ProjectUpdates系列文章的一部分。在这篇博文中，我们将分享该项目的最新进展，该项目是在2018年KubeCon欧洲博览会上公布的。

## Litmus项目的目的

### Litmus项目的目的

Litmus项目的目地在于通过以存储和基础设施为重点的首尾相连的端(e2e)测试来帮助评估Kubernetes上有状态的工作负载，这些测试使用了混沌工程工具和原理，以及其他辅助工具，测试用例作为Kubernetes作业执行。在过去的10个月里，基于社区反馈的框架有了一些改进，同时测试库也有所增加。在此期间的重点领域和改进、正在进行的工作和即将出现的特性将在后续部分中总结。

### 增加了应用程序和用例的覆盖率

虽然Litmus的初始焦点围绕创建一个K8s的e2e本地方法(通过测试容器部署工作)、形成一个更简单的接口为用户定义、生成测试通过类似英语的句子(使用godog),后续的反馈充满活力并且涉及OpenEBS社区中,用户能够选择测试用例,即..可部署测试作业的从现有的测试库,使快速周转时间状态的工作量评估。因此，现有的基于配置文件的utils得到了扩展。

Litmus现在包括对多个受欢迎的有状态的应用程序的支持(Percona MysQL, MongoDB, Apache Cassandra, MongoDB, Minio, Crunchy PostgreSQL, NuoDB, Prometheus等)，同时涵盖常见的应用运行全过程的场景，如部署，加载，重新安排，扩展，升级和删除。还包括测试作业，以验证这些工作负载对持久性存储和集群基础设施的间歇性和永久性故障的弹性，这些故障是通过混乱工具所引起的。

### 将Litmus重构为一个更“面向微服务”的模型

微服务领域的原则之一是将应用程序服务划分为几个部分，以便在管理中实现更大的灵活性和对其的管理控制。当Litmus项目启动时，测试的整个工作流程:从应用程序部署开始，通过测试业务逻辑进行清理，然后嵌入到单个作业中。虽然在某些情况下这仍然是一个可行的模型，但是在工作流的每个阶段管理多个用户输入或排列意味着在单个作业中，处理它将使得测试成为一个复杂的“庞然大物”并影响它的可调试性。

![](https://blog.mayadata.io/hs-fs/hubfs/Blog%20Images-60.png?width=834&name=Blog%20Images-60.png)

持续集成(CID)管道运输

另一个需要考虑的问题是，Litmus测试被用来驱动目的在与模拟用户环境的持续集成(CI)管道运输，在这种环境中，应用程序通常在一段时间内经历各种day-1/day-2-n操作，同时对组件故障具有可迅速恢复的性能。这就产生了不同种类的Litmus作业(此后可互换称为Litmusbooks)，它们可以按照特定的顺序组合，以实现“e2e测试”或“Litmus试验”。

**应用程序部署者或取消供应者:**
Litmusbooks采用各种参数，如名称空间、类型、标签、活性(IO)探测等，以部署或清理上述应用程序。

**负载生成器:**
使用自定义集装箱模拟客户端行为，在应用程序上生成并且合成(fio、sysbench、dd)和特定于应用程序(TPC-C、YCSB)的IO负载。

**外部活性检测器:**
检测对应用服务器的可访问性。当标准的K8s活性或lO探针执行pod重启以恢复应用服务器的健康状态时，这些外部检测器在应用程序运行全过程进行操作或在混乱期间测试“终端应用程序”的无缝连续性。

**应用程序或存储运行全过程的“操作人员”:**
执行标准功能操作，如应用程序或存储规模、备份或还原、重定进度、应用程序或存储的升级等。(不应被误认为是实际的“kubernetes运营商”)

**混乱诱导器:**
导致集群中指定目标失败的Litmusbooks，包括应用程序副本、存储和集群基础设施(网络、节点、磁盘、内存、CPU)

## Litmus框架

### Litmus框架

通常，运行的全过程功能和混乱litmusbooks包括对应用程序和持久存储组件进行测试后所进行的是否健全检查的步骤，包括数据完整性验证。所有以上的需求都需要创建多个“测试促进器容器”(在这里维护)来实现基于python的应用程序客户端，并集成其他流行的开源工具，如pumba、chaostoolkit&chaoskube。

有关使用Litmus的混沌工程的更多细节，请阅读本文。

### Litmus e2e 测试结果可视化工具

在CI框架中采用任何给定的测试(套件)的重要因素之一是确定测试成功或失败的结果机制。在上述提到的过程期间,Litmus从测试容器提取结果日志在Kubernetes静态定义资源(“litmusresult”，由测试代码在测试执行的开始和结束时通过JSON合并补丁操作更新)，资源名基于usertags动态生成。这个资源还包含其他的测试元数据，例如applype、testType、testStatus等等，除了实际的结果之外。实现或运行Litmusbooks的CI作业可以配置成从这些CRs获取作业的状态。

https://cdn-images-1.medium.com/max/800/1*FRu2 jl_3AZ101J2wwi81Q.png

一个描述结果CR结构的jinja模板

### 其他需要注意的改进

该项目还看到了其他一些根本的变化，这些变化导致它更快地被CI系统采用，并提高了测试的效率。简要叙述如下:

**下文设置脚本:**
Litmus现在提供多个工具脚本来帮助快速、轻松地创建Kubernetes集群在不同销路的云平台(GCP,AWS,GKE,AKS,EKS,Packet Cloud,On-premise vSphere VMs,OpenShift-on-AWS, OpenShift-on-vSphere)以最少的配置输入和litmusbooks设置OpenEBS k8集群控制平面。

**简化Litmus设置:**
设置RBAC、CRDs和config文件更新的简单交互式bash脚本负责Litmus设置的先决条件。

**特定于k8的增强:**
其中包括使litmusbooks更稳健的小更改，比如:

* 在Litmus作业中使用generate Name API以确保重复执行不会导致失败
* 在测试代码中使用的kubectl命令中最大限度地使用标签和JSONPATH表达式，而不是bash实用程序，以防止K8s集群版本和存储资源的更改。
* 增加使用pod环境变量(特定于用户的和向下的API)以k8-本地方式控制测试输入，而不是以特定于测试代码的形式通过它们(ansible extra-vars)

**增加了测试代码的模块化:**
大部分测试代码在litmusbooks中被重用，由于这些可重用的任务被作为单独的util进行管理，这些被进一步归类为公共的、混乱的、带有定义良好的接口的应用程序或存储生命周期规则。

**Litmus CI:**
Litmus(和测试工具)项目现在由它自己的基于Travis的CI组成，它在ansible /Python lint/语法检查操作之后构建各自的运行器映像。

**优化的测试图像:**
litmus runner (go, ansible)和测试助推器的图像已经根据所使用的层数、大小和二进制版本进行了优化。

**案例研究:**
Litmus驱动的OpenEBS CI

## Litmus驱动的OpenEBS CI

OpenEBS项目的持续集成框架，即它的各种组件，如Maya, Node-Disk-Manager(控制平面)，Jiva, cStor(数据平面)是使用Gitlab，与e2e测试执行通过Litmusbooks和支持基于Elasticsearch-Fluentd-Kibana (EFK)的登录框架。在构建阶段(构建上述组件并将图像推送到相应的存储库)后，将触发基于Kubernetes集群版本的多个gitlab e2e管道，每个管道包括以下由lits支持的阶段:

* 在裸金属云平台包上创建K8s集群
* 部署OpenEBS控制平面
* 部署有状态的应用程序
* 运行应用程序和存储生命周期操作
* 导致应用程序、OpenEBS持久性存储和集群基础设施混乱
* 取消应用程序和OpenEBS控制平面
* 删除K8s集群资源

gitlab运行器脚本遵循一个已经被定义好的模式，该模式涉及litmusbook预处理(用户输入)、litmusbook执行和对结果自定义资源的监测，gitlab作业(以及相应的阶段)的成功就是从这个模式派生出来的。

openebs.ci 为各种提交到openebs控制平面和数据平面项目的构建状态提供了一个仪表板视图，详细显示了各个阶段/作业状态和Kibana上的各个日志。它还提供了一个使用openebspv实时查看正在运行的生产工作负载的视图，这些工作负载是在多个OpenEBS版本上进行维护的，其中一个选项是在应用程序/存储组件上引发随机混乱和查看行为。Litmus混沌模块被称为内部实现这一点。

关于这个CI框架的组成和功能的更多细节可以在这篇博客中找到。

### Litmus正在进行的努力和即将具有的特点

此时，Litmus的贡献主要集中在增加应用程序和存储生命周期的测试，更具体地说，标准且有状态应用程序的第2天操作会同时继续，以增加当前测试的稳定性。

一些近期的改进和增强包括:

* 发布Litmus项目的文档
* 改进Litmus结果CR以保持实时状态，增加了故障元数据，包括捕获应用程序状态的能力
* 开发额外的基础设施和应用程序特定的混沌点

### 结论

Litmus项目的改进之所以成为可能，是因为社区在反馈和贡献方面提供了惊人的支持。所以，非常感谢你，并期待更多的相同的进步!!