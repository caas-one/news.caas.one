![](https://banzaicloud.com/img/team/nandor-kracser.jpg)

Nandor Kracser

星期一，2018年10月8日
# 在K8s上使用Vault的Spring Boot

Banzai Cloud的[Pipeline](https://github.com/banzaicloud/pipeline)提供了一个平台，允许企业开发，部署和扩展基于容器的应用程序。它利用最佳的云组件（如K8s）为开发人员和运营团队创建高效，灵活的环境。强大的安全措施 , 多重身份验证后端，细粒度授权，动态秘密管理，使用TLS的组件之间的自动安全通信，漏洞扫描，静态代码分析等等 - 都是[Pipeline](https://github.com/banzaicloud/pipeline)平台的基础功能，我们力求自动化并为所有企业提供支持。

# Spotguides

我们正在发布第一组要与用户共享[Spotguides](https://banzaicloud.com/blog/spotguides-revisited/)。Spotguides是通过[Pipeline](https://banzaicloud.com/blog/spotguides-revisited/)从骨架项目创建的，您可以在创建阶段和之后根据需要来配置它们。我们已经通过[Bank-Vaults](https://github.com/banzaicloud/bank-vaults/issues)项目和[Vault Helm图表](https://github.com/banzaicloud/banzai-charts/tree/master/vault)进行了大量投资[Vault](https://vaultproject.io/)。此外，我们认为所有没有Java支持的现代企业应用程序平台都是不可行的。[Spring Boot](https://spring.io/projects/spring-boot)是最着名的Java应用程序框架之一; 它建立在Spring框架之上，并自动支持DI，Web和配置支持，具有看似无限数量的子项目，用于处理云，数据，移动，安全等。幸运的是，还为Spring编写了很好的Vault集成，称为[Spring Vault](https://projects.spring.io/spring-vault/)。这篇博文将试图描述如何在K8s上使用Spring Boot并以适当的方式从Java应用程序访问Vault。它将突出显示工作流应该是什么样的，从打包应用程序和构建Docker容器到使用Helm在K8s上发布服务，并描述未来增强的可能性。最后，该项目将作为spotguide模板。

![](https://banzaicloud.com/img/blog/java-vault/java-vault.png)


# Spring Boot设置
从头开始创建一个Java项目可能是一个繁琐乏味的过程，但是Spring Boot有一个不错的网站，它为您的应用程序生成一个模板，并提供了许多配置的可能性。这个引导页面称为[SPRING INITIALIZR](https://start.spring.io/)。对于我们的服务，我们将使用Maven，Java，Spring 2.0.5（最新发布的版本）。额外依赖的将是[Vault Configuration](https://cloud.spring.io/spring-cloud-vault/)和[Reactive Web](https://cloud.spring.io/spring-cloud-vault/)。在配置后下载应用程序，并在您选择的IDE或文本编辑器中打开它（我使用的是IntelliJ IDEA）。我们将使用具有最新语言功能的Java 11，以便从Java的[新发布计划](https://mreinhold.org/blog/forward-faster)中受益。导入这个项目后，它应该已经可以运行（在`src`里搜索`*.java`）。它不会做太多（虽然它确实很有用）但应该足以让我们停下来考虑我们如何打包应用程序并以有效的方式从中构建Docker镜像（我们的示例项目可在[GitHub](https://github.com/banzaicloud/spotguide-java-vault)上获得。

# 从基于JVM的应用程序构建Docker镜像

我看过许多描述如何做到这一点的教程，我可以告诉你，很难做到这一点。Java是一种编译语言，这意味着您必须在使用JVM运行JAR文件之前创建它。随着[多阶段](https://docs.docker.com/develop/develop-images/multistage-build/) Docker构建的引入，这个过程比以前更容易。这就是我们的`Dockerfile`样子。
```
 1 FROM maven:3.5-jdk-11-slim as build
 2
 3 # Resolve all the dependencies and cache them to save a LOT of time
 4 COPY pom.xml /usr/src/myapp/
 5 RUN mvn -f /usr/src/myapp/pom.xml dependency:resolve dependency:resolve-plugins
 6
 7 # Build the application - usually this is the only part that gets rebuilt locally - use offline mode and skip tests
 8 COPY src /usr/src/myapp/src
 9 RUN mvn -f /usr/src/myapp/pom.xml clean package -DskipTests -o
10
11
12 # The final image should have a minimal number of layers
13 FROM openjdk:11-jre-slim
14
15 COPY --from=build /usr/src/myapp/target/app.jar app.jar
16
17 ENTRYPOINT java -Djava.security.egd=file:/dev/./urandom -jar app.jar
```
多阶段构建有助于创建具有最小层和大小的最终Docker镜像，因此只有与JVM一起打包的最终应用程序JAR才是您在映像中提供的内容。但是构建这个应用程序需要花费大量的时间，即使是在我相当新的2017款MacBook Pro上也是如此; Spring有很多依赖项（和插件），每次运行时Maven都会下载它们：
```
1 docker build -t banzaicloud/spotguide-java-vault:latest .
```
为了解决这个问题，打包JAR文件分为两部分：

- 下载所有项目依赖项和插件（这取决于您的`pom.xml`）
- 编译代码并构建应用程序JAR

使用这种技术，如果您不更改pom.xml（并且不会像您的Java代码那样频繁地更改它），您可以[利用Docker构建缓存](https://docs.docker.com/develop/develop-images/dockerfile_best-practices/#leverage-build-cache)来节省大量的构建时间。这样就可以在几秒钟内将Docker镜像放入本地测试中，而不是超过几分钟。
```
 1 » docker build -t banzaicloud/spotguide-java-vault:latest .
 2 Sending build context to Docker daemon  586.8kB
 3 Step 1/8 : FROM maven:3.5-jdk-11-slim as build
 4 ---> 3f31430076c8
 5 Step 2/8 : COPY pom.xml /usr/src/myapp/
 6 ---> Using cache
 7 ---> 4efc687be56a
 8 Step 3/8 : RUN mvn -f /usr/src/myapp/pom.xml dependency:resolve dependency:resolve-plugins
 9 ---> Using cache
10 ---> 4fe04ff7dad5
11 Step 4/8 : COPY src /usr/src/myapp/src
12 ---> Using cache
13 ---> d05e6bf6588b
14 Step 5/8 : RUN mvn -f /usr/src/myapp/pom.xml clean package -DskipTests -o
15 ---> Running in c0b92c27204f
16 [INFO] Scanning for projects...
17 [INFO]
18 [INFO] ------------------< com.banzaicloud:vault-spotguide >-------------------
19 [INFO] Building vault-spotguide 0.0.1-SNAPSHOT
20 [INFO] --------------------------------[ jar ]---------------------------------
21 [INFO]
22 [INFO] --- maven-clean-plugin:3.0.0:clean (default-clean) @ vault-spotguide ---
```
# 为Java应用程序创建Helm图表
使用`helm create [APP]`可以从头开始快速创建新的Helm图表。要使用您的应用程序能在带有Helm在K8s上运行，请替换标准值`image.repository`和`image.tag`的值。不要忘记更改`livenessProbe`容器，因为启动JVM，加载所有Spring资源，并使应用程序运行并打开TCP端口需​​要一些时间（通常超过默认查看值）：
```
1      livenessProbe:
2        httpGet:
3          path: /
4          port: http
5        initialDelaySeconds: 30 # When using resource limits the JVM needs some time to start-up
```
该图表将作为整个应用程序的总体图表。

# 使用MySQL存储后端设置高可用集群 Vault
用于Vault的MySQL存储后端已经存在很长时间了，但[Vault 0.11](https://www.hashicorp.com/blog/vault-0-11)最近也引入了对MySQL的高可用集群存储后端支持。这意味着如果MySQL支持，您可以以高度可用的方式运行Vault。Vault不存储任何数据，但它使用所谓的存储后端来存储加密数据，有关详细信息，请参阅其[体系结构文档](https://www.hashicorp.com/blog/vault-0-11)。

在[MySQL社区图表](https://github.com/helm/charts/tree/master/stable/mysql)和[Banzai Cloud Vault图表](https://github.com/banzaicloud/banzai-charts/tree/master/vault)的帮助下，很容易在K8s上完成上述设置。在总体图表的`values.yaml`文件中，您必须添加以下两个块：
```
 1 # Configure MySQL to create a user and a database called `vault` and give the user access to to the db:
 2 mysql:
 3  mysqlUser: vault
 4  mysqlPassword: vault
 5  mysqlDatabase: vault
 6
 7 vault:
 8  # Configure Vault to have two instances (required for the HA setup)
 9  replicaCount: 2
10
11  # Use the latest version of the bank-vaults Vault unsealer
12  # (by default it uses Kubernetes secrets)
13  unsealer:
14    image:
15      tag: latest
16
17  vault:
18    image: 0.11.1
19    config:
20      storage:
21        # Tell Vault to use MySQL as the storage backend in HA mode
22        # and give the access details to it
23        mysql:
24          # The Kubernetes service name of MySQL
25          address: spotguide-java-vault-mysql:3306
26          username: vault
27          password: vault
28          ha_enabled: "true"
29      # The Kubernetes service name of Vault
30      api_addr: "https://spotguide-java-vault-vault:8200"
```
为了便于阅读，所有MySQL密码都是很简单的`vault`，但您可以随时使用Helm的`--set`命令更改它们：
```
1 export MYSQL_PASSWORD=myS3cr3tPassw0rd
2
3 helm upgrade --install spotguide-java-vault .banzaicloud/charts/spotguide-java-vault \
4  --set mysql.mysqlPassword=${MYSQL_PASSWORD} \
5  --set vault.vault.config.storage.mysql.password=${MYSQL_PASSWORD}
```
值得一看的是，[Banzai Cloud Vault图表](https://github.com/banzaicloud/banzai-charts/tree/master/vault)如何通过其API支持自动配置Vault，比如应用Vault [策略](https://www.vaultproject.io/docs/concepts/policies.html)和安装[Auth后端](https://github.com/banzaicloud/banzai-charts/tree/master/vault)。这些帮助用户利用Helm来配置完整的Vault安装：
```
 1    externalConfig:
 2      policies:
 3      - name: allow_secrets
 4        rules:
 5          path "secret/data/*" {
 6            capabilities = ["create", "read", "update"]
 7          }
 8          path "secret/metadata/*" {
 9            capabilities = ["delete", "list"]
10          }
11          path "sys/mounts" {
12            capabilities = ["read", "list"]
13          }
14      auth:
15      - type: kubernetes
16        # Allows creating roles in Vault, which can be used later on for the Kubernetes based
17        # authentication.
18        # See https://www.vaultproject.io/docs/auth/kubernetes.html#creating-a-role for
19        # more information.
20        roles:
21        # Allows the application pod in the all namespaces to use the secret kv store
22        - name: application
23          bound_service_account_names: default
24          bound_service_account_namespaces: "*"
25          policies: allow_secrets
26          ttl: 10m
```
最后，将两个图表添加到您的`requirements.yaml`：
```
1 dependencies:
2  - name: mysql
3    version: 0.10.1
4    repository: "@stable"
5  - name: vault
6    repository: http://kubernetes-charts.banzaicloud.com/branch/master
7    version: 0.5.13
```
您不必初始化和开启Vault ，因为[Bank-Vaults项目](https://banzaicloud.com/blog/announcing-bank-vaults/)会处理这个问题。在这个例子中，`K8s Secrets`用于存储密钥和执行路径，这仅用于开发的目的。在Vault Spotguide中，您将能够选择要使用的KMS后端。

# 编写Spring Boot / Vault应用程序
编写Spring应用程序是此过程中最简单的部分。因为它是一个非常基本的应用程序，可以代理Vault API的某些部分，所以它可以列出安装，以及创建和列出secrets。

我们的主题依赖于`VaultController.java`：
```
 1 @RestController
 2 public class VaultController {
 3
 4    @Autowired
 5    private VaultOperations vaultOperations;
 6
 7    @GetMapping("/mounts")
 8    public Map<String, VaultMount> mounts() {
 9        return vaultOperations.opsForSys().getMounts();
10    }
11
12    @GetMapping("/secrets")
13    public List<Map<String, Object>> secrets() {
14        return vaultOperations.list("secret/metadata/")
15                .stream()
16                .map((key) -> Map.of("id", key, "data", readSecret(key)))
17                .collect(Collectors.toList());
18    }
19
20    @GetMapping("/secrets/{id}")
21    public Map<String, Object> secrets(@PathVariable("key") String key) {
22        return readSecret(key);
23    }
24
25    private Map<String, Object> readSecret(String key) {
26        return vaultOperations.read("secret/data/" + key).getData();
27    }
28
29    @PostMapping(value = "/secrets")
30    public void createSecret(@RequestBody Map<String, String> body) {
31        vaultOperations.write(
32                "secret/data/" + UUID.randomUUID().toString(),
33                Map.of("data", body)
34        );
35    }
36
37    @RequestMapping("/")
38    public String health() {
39        return "OK";
40    }
41 }
```
使用cURL练习API：
```
1 # Create a secret
2 curl -H "Content-Type: application/json" http://localhost:8080/secrets \
3  -d '{"i-have-to-say":"spring-boot-is-great"}'
4
5 # List secrets
6 curl http://localhost:8080/secrets | jq
7
8 # List mounts
9 curl http://localhost:8080/mounts | jq
```
# Spring Boot和Vault之间的TLS
所述[ Banzai Cloud Vault helm图表](https://github.com/banzaicloud/banzai-charts/tree/master/vault)强制使用TLS来访问Vault K8s服务。它通过自签名证书来实现这一点的。为了能够信任自签名服务器证书，您需要拥有CA证书（`ca.crt`）以确保签名者是可信的。

以PEM格式存储证书是[标准的](https://github.com/banzaicloud/banzai-charts/tree/master/vault)。Vault使用PEM和能生成证书的Helm。

然而，Java有自己的存储证书的方式，称为[JKS](https://en.wikipedia.org/wiki/Keystore)（Java KeyStore）格式。

所以我们必须将ca.crt从PEM转换为JKS格式。理想情况下，JRE附带了一个用于此目的的工具，叫做`keytool`。我们在[初始化容器](https://en.wikipedia.org/wiki/Keystore)时执行此操作：
```
 1    spec:
 2      initContainers:
 3        - name: {{ .Chart.Name }}-jks
 4          image: "{{ .Values.image.repository }}:{{ .Values.image.tag }}"
 5          imagePullPolicy: {{ .Values.image.pullPolicy }}
 6          command:
 7            - keytool
 8            - -importcert
 9            - -storepass
10            - {{ derivePassword 1 "long" (.Release.Time | toString) "banzai" "cacert" }}
11            - -noprompt
12            - -file
13            - /vault/cacert/ca.crt
14            - -keystore
15            - /vault/jkscacert/ca.jks
16          volumeMounts:
17            - mountPath: /vault/cacert
18              name: vault-cacert
19            - mountPath: /vault/jkscacert
20              name: vault-jks-cacert
21
22 // ... the main container
23
24          env:
25            - name: VAULT_URI
26              value: https://{{ .Release.Name }}-vault:8200
27            - name: VAULT_SSL_TRUST_STORE
28              value: file:///vault/cacert/ca.jks
29            - name: VAULT_SSL_TRUST_STORE_PASSWORD
30              value: {{ derivePassword 1 "long" (.Release.Time | toString) "banzai" "cacert" }}
31          volumeMounts:
32          - mountPath: /vault/cacert
33            name: vault-jks-cacert
34
35 // ... the volumes
36
37      # Mount the Secret holding the generated self-signed certificate for Vault
38      # Create an ephemeral Volume for holding the converted version of the ca.crt to JKS
39      volumes:
40        - name: vault-cacert
41          secret:
42            secretName: {{ .Release.Name }}-vault-tls
43        - name: vault-jks-cacert
44          emptyDir: {}
```
Spring Vault必须知道此证书才能使用它来访问Vault。因为它有一个很好的[12因素应用程序](https://12factor.net/)风格配置类，称为[EnvironmentVaultConfiguration](https://docs.spring.io/spring-vault/docs/current/reference/html/index.html#vault.core.environment-vault-configuration)，因此很容易让它知道（参见`env`:主容器的模块）。

*注意*：这里使用Helm 的`derivePassword`函数在模板的两个不同位置生成相同的随机文本。

我们已经在[之前的](https://docs.spring.io/spring-vault/docs/current/reference/html/index.html#vault.core.environment-vault-configuration)一篇文章中描述了root和leaf证书之间的关系，请参阅更多详细信息。

# 摘要
您可以从[GitHub](https://docs.spring.io/spring-vault/docs/current/reference/html/index.html#vault.core.environment-vault-configuration)下载整个项目并在您的机器上启动它：
```
1 # This assumes Docker for Mac with Kubernetes enabled
2
3 docker build -t banzaicloud/spotguide-java-vault:latest .
4 helm dep update .banzaicloud/charts/spotguide-java-vault
5 helm upgrade --install spotguide-java-vault \
6             .banzaicloud/charts/spotguide-java-vault \
7             --set ingress.enabled=true \
8             --set "ingress.hosts[0]=localhost"
9 open http://localhost
```
我们很高兴收到关于我们在这篇文章中没有涉及到的与这个主题有关的任何事情的来信。

如果您对我们的技术和开源项目感兴趣，请关注[GitHub](https://github.com/banzaicloud/pipeline)，[LinkedIn或Twitter](https://twitter.com/BanzaiCloud?ref_src=twsrc%5Etfw)。

![](https://banzaicloud.com/img/try_pipeline_button.svg)
